<!doctype html>
<html lang="en">
<head>
  <script type="module" src="/src/uiEnhancements.ts"></script>
  @media (max-width: 380px) { canvas { width:240px; height:480px; } }
  /* Prevent accidental scroll / bounce when interacting */
  canvas, .control-grid, button { touch-action:none; -webkit-touch-callout:none; }
  </style>
</head>
<body>
  <div id="stage">
  <div id="root" class="app-shell">
      <div id="gameWrap" class="card-equal">
        <canvas id="game" width="300" height="600"></canvas>
        <div id="overlay" class="visible">READY</div>
      </div>
      <div class="panel">
        <div class="logo-wrap">
          <img id="gameLogo" alt="Tetris Logo" decoding="async" />
        </div>
        <div class="stats pro-grid">
          <div id="score" class="stat span-2 emphasis"><div class="stat-top"><span class="stat-label">Score</span><span class="delta" id="scoreDelta"></span></div><span id="scoreVal" class="stat-val big">0</span><div class="progress-wrap"><div id="levelProgress" class="progress-bar"></div></div></div>
          <div id="level" class="stat"><span class="stat-label">Level</span><span id="levelVal" class="stat-val">1</span></div>
          <div id="lines" class="stat"><span class="stat-label">Lines</span><span id="linesVal" class="stat-val">0</span></div>
          <div id="highScore" class="stat"><span class="stat-label">High</span><span id="highVal" class="stat-val">0</span></div>
        </div>
        <div id="toastLayer" class="toast-layer"></div>
        <div class="divider" style="margin-top:10px;"></div>
        <button id="startBtn">Start / Pause</button>
        <button id="resetBtn" style="margin-top:8px;">Reset</button>
        <div class="divider" style="margin:12px 0 8px;"></div>
        <div class="control-grid">
          <button id="btnUp" style="grid-column:2;">▲</button>
          <button id="btnLeft">◀</button>
          <button id="btnDown">▼</button>
          <button id="btnRight">▶</button>
          <button id="btnHard" style="grid-column:3;">⤓</button>
        </div>
        <div class="foot" style="margin-top:12px;">
          Keyboard: Arrows / Space / Shift / R
        </div>
      </div>
    </div>
  </div>
  <script>
    // Professional scoreboard enhancements
    (function(){
      const nf = new Intl.NumberFormat('en-US');
      const scoreEl = document.getElementById('scoreVal');
      const levelEl = document.getElementById('levelVal');
      const linesEl = document.getElementById('linesVal');
      const highVal = document.getElementById('highVal');
      const scoreStat = document.getElementById('score');
      const levelProgress = document.getElementById('levelProgress');
      const scoreDelta = document.getElementById('scoreDelta');
      const toastLayer = document.getElementById('toastLayer');
      let lastScore = 0;
      function showToast(text, opts={}) {
        if(!toastLayer) return; const div = document.createElement('div');
        div.className = 'toast ' + (opts.type||''); div.textContent = text;
        toastLayer.appendChild(div);
        setTimeout(()=> div.classList.add('out'), opts.ttl || 1600);
        setTimeout(()=> div.remove(), (opts.ttl||1600)+480);
      }
      window.addEventListener('tetris-level-up', e => {
        const { level } = e.detail;
        showToast('LEVEL '+ level, { type:'good', ttl: 1700 });
        scoreStat?.classList.add('pulse');
        setTimeout(()=> scoreStat?.classList.remove('pulse'), 620);
      });
      window.addEventListener('tetris-line-clear', e => {
        const { cleared, score } = e.detail;
        if (cleared === 4) { showToast('TETRIS +' + nf.format(score - lastScore), { type:'good', ttl:1900 }); }
        else if (cleared === 3) { showToast('TRIPLE', { type:'good', ttl:1400 }); }
        else if (cleared === 2) { showToast('DOUBLE', { ttl:1200 }); }
        else if (cleared === 1) { showToast('LINE', { ttl:1000 }); }
        if (scoreDelta && score > lastScore) {
          scoreDelta.textContent = '+' + nf.format(score - lastScore);
          scoreDelta.classList.add('visible');
          setTimeout(()=> scoreDelta.classList.remove('visible'), 1200);
        }
        lastScore = score;
      });
      const observer = new MutationObserver(()=>{
        const currentLines = parseInt(linesEl?.textContent||'0',10);
        const into = currentLines % 10;
        if (levelProgress) levelProgress.style.width = ((into/10)*100).toFixed(1)+'%';
        // Format numbers once they change (idempotent)
        if (scoreEl) { const raw = scoreEl.textContent||'0'; const num = Number(raw.replace(/[,]/g,'')); scoreEl.textContent = nf.format(num); }
        if (highVal) { const raw = highVal.textContent||'0'; const num = Number(raw.replace(/[,]/g,'')); highVal.textContent = nf.format(num); }
      });
      const statsRoot = document.querySelector('.stats');
      if (statsRoot) observer.observe(statsRoot, { subtree:true, characterData:true, childList:true });
    })();
  </script>
  <script>
    // Runtime remote logo injection (no local file). Priority:
    // 1. ?logo= URL param
    // 2. window.__TETRIS_LOGO_URL__ (can be injected by preload or env define)
    // 3. Fallback SVG wordmark (inline)
    (function(){
      const params = new URLSearchParams(location.search);
      const paramLogo = params.get('logo');
  const globalLogo = (window && window.__TETRIS_LOGO_URL__) || undefined;
  // Removed XML declaration to prevent parse5 HTML build error on Netlify ("unexpected-question-mark-instead-of-tag-name")
  const fallbackSvg = 'data:image/svg+xml;utf8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="220" height="54" viewBox="0 0 220 54"><defs><linearGradient id="g" x1="0" x2="1" y1="0" y2="1"><stop stop-color="#4f7ff9"/><stop offset="1" stop-color="#8b5cf6"/></linearGradient></defs><rect width="220" height="54" rx="10" fill="rgba(255,255,255,0.04)"/><text x="50%" y="52%" dominant-baseline="middle" text-anchor="middle" font-family="Segoe UI,Inter,Arial,sans-serif" font-size="30" font-weight="600" fill="url(#g)">TETRIS</text></svg>');
      const el = document.getElementById('gameLogo');
      if(!el) return;
      // New implicit fallback to /logo.png so you can just drop a file at public/logo.png
      // Order: query param > injected global > /logo.png > inline SVG
      const candidate = paramLogo || globalLogo || '/logo.png';
      el.src = candidate;
      el.addEventListener('error', () => { el.src = fallbackSvg; });
      // After the logo loads, if it's a raster image with a bright (white) outline, replace those outline pixels
      // with a darker tone derived from the interior average color for a flatter modern look.
      el.addEventListener('load', () => {
        if(el.dataset.processed) return; // avoid double work
        // Skip SVG data URIs (already vector without white stroke)
        if(/^data:image\/svg/.test(el.src)) return;
        try {
          const canvas = document.createElement('canvas');
          const w = canvas.width = el.naturalWidth || el.width;
          const h = canvas.height = el.naturalHeight || el.height;
          if(!w || !h) return; // nothing to do
          const ctx = canvas.getContext('2d', { willReadFrequently:true });
          ctx.drawImage(el, 0, 0);
          let imgData;
          try { imgData = ctx.getImageData(0,0,w,h); } catch(e){ return; } // likely cross-origin taint
          const d = imgData.data;
          let sumR=0,sumG=0,sumB=0,count=0;
          // First pass: gather average of non-white, non-transparent interior pixels
          for(let i=0;i<d.length;i+=4){
            const a = d[i+3]; if(a < 180) continue; // ignore near transparent
            const r=d[i],g=d[i+1],b=d[i+2];
            if(r>215 && g>215 && b>215) continue; // skip near-white (potential outline)
            sumR+=r; sumG+=g; sumB+=b; count++;
          }
            if(!count) return; // can't derive palette
          const avgR=sumR/count, avgG=sumG/count, avgB=sumB/count;
          // Create a darker stroke color ~35% brightness of average (but keep some saturation)
          const darken = c => Math.max(0, Math.min(255, Math.round(c*0.38)));
          const strokeR = darken(avgR);
          const strokeG = darken(avgG);
          const strokeB = darken(avgB);
          // Second pass: remap near-white pixels to stroke color while preserving alpha
          for(let i=0;i<d.length;i+=4){
            const a = d[i+3]; if(a < 50) continue; // skip mostly transparent
            const r=d[i],g=d[i+1],b=d[i+2];
            if(r>215 && g>215 && b>215){
              d[i] = strokeR;
              d[i+1] = strokeG;
              d[i+2] = strokeB;
            }
          }
          ctx.putImageData(imgData,0,0);
          el.src = canvas.toDataURL('image/png');
          el.dataset.processed = 'true';
        } catch(err){ /* silent fallback */ }
      });
    })();
  </script>
  <script type="module" src="/src/main.ts"></script>
  <script>
    // Basic mobile button press repeat for left/right (minimal, does not affect desktop)
    (function(){
      const btnL = document.getElementById('btnLeft');
      const btnR = document.getElementById('btnRight');
      const btnD = document.getElementById('btnDown');
      if(!btnL||!btnR||!btnD) return;
      function repeater(el, fire){
        let t, hold=false;
        const start = (e)=>{ e.preventDefault(); fire(); hold=true; let delay=260; const loop=()=>{ if(!hold) return; fire(); delay = Math.max(55, delay*0.75); t=setTimeout(loop, delay); }; t=setTimeout(loop, delay); };
        const end=()=>{ hold=false; if(t) clearTimeout(t); };
        el.addEventListener('pointerdown', start, {passive:false});
        window.addEventListener('pointerup', end);
        window.addEventListener('pointercancel', end);
      }
      // Expose simple commands through custom events to main.ts (decoupled)
      repeater(btnL, ()=>window.dispatchEvent(new CustomEvent('tetris-btn-left')));
      repeater(btnR, ()=>window.dispatchEvent(new CustomEvent('tetris-btn-right')));
      repeater(btnD, ()=>window.dispatchEvent(new CustomEvent('tetris-btn-down')));
    })();
  </script>
  <script>
    // Equalize heights: match game card height to .panel (right side) once images/fonts load
    function syncHeights(){
      const panel = document.querySelector('.panel');
      const wrap = document.getElementById('gameWrap');
      if(!panel || !wrap) return;
      // Disable forced equal height on narrow/mobile layout so page can scroll naturally.
      if(window.innerWidth <= 520){
        wrap.style.height = '';
        return;
      }
      const h = panel.getBoundingClientRect().height;
      wrap.style.height = h + 'px';
    }
    window.addEventListener('load', () => { syncHeights(); setTimeout(syncHeights, 50); });
    window.addEventListener('resize', syncHeights);
  </script>
</body>
</html>
